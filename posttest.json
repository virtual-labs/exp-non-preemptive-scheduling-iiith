{
	"version": 2.0,
	"questions": [
	  {
		"question": "How does preemptive scheduling affect the waiting time of processes?",
		"answers": {
		  "a": "It increases the waiting time due to context switching",
		  "b": "It decreases the waiting time by allowing higher-priority processes to execute first",
		  "c": "It does not affect the waiting time",
		  "d": "It causes no effect on the process execution order"
		},
		"explanations": {
		  "a": "In preemptive scheduling, context switching can lead to an increase in waiting time, as processes are interrupted frequently.",
		  "b": "Preemptive scheduling allows critical tasks to execute earlier, which can decrease waiting time for those processes but not always for others.",
		  "c": "Preemptive scheduling does affect waiting time by reordering the execution of processes based on priority or time slice.",
		  "d": "Preemptive scheduling significantly alters the execution order based on priorities and time slices."
		},
		"correctAnswer": "a",
		"difficulty": "intermediate"
	  },
	  {
		"question": "Which of the following is an advantage of non-preemptive scheduling?",
		"answers": {
		  "a": "Lower waiting times",
		  "b": "Reduced context switching overhead",
		  "c": "Higher throughput",
		  "d": "Faster response time"
		},
		"explanations": {
		  "a": "Non-preemptive scheduling can sometimes cause higher waiting times if long processes block the queue.",
		  "b": "Non-preemptive scheduling requires fewer context switches as processes run to completion once started, reducing overhead.",
		  "c": "Non-preemptive scheduling may reduce throughput if longer jobs monopolize the CPU.",
		  "d": "It typically results in slower response times because shorter jobs might have to wait for longer jobs to complete."
		},
		"correctAnswer": "b",
		"difficulty": "intermediate"
	  },
	  {
		"question": "Which scheduling type is more likely to lead to starvation of lower-priority processes?",
		"answers": {
		  "a": "Round-robin",
		  "b": "Preemptive scheduling",
		  "c": "Non-preemptive scheduling",
		  "d": "First-come, first-served"
		},
		"explanations": {
		  "a": "Round-robin ensures each process gets CPU time, minimizing starvation risk.",
		  "b": "Preemptive scheduling is designed to rotate processes efficiently and fairly, especially with round-robin or aging techniques.",
		  "c": "Non-preemptive scheduling can lead to starvation as long processes or those with high priority can block others indefinitely.",
		  "d": "First-come, first-served may delay short jobs, but doesn't inherently cause starvation since all jobs eventually proceed."
		},
		"correctAnswer": "c",
		"difficulty": "intermediate"
	  },
	  {
		"question": "Which of the following factors affects the performance of preemptive scheduling?",
		"answers": {
		  "a": "Time slice length",
		  "b": "Number of processes in the queue",
		  "c": "Priority of processes",
		  "d": "Amount of available memory"
		},
		"explanations": {
		  "a": "In preemptive scheduling, the time slice length determines how often context switches happen, directly impacting performance.",
		  "b": "While the number of processes increases system load, it affects all scheduling methods, not just preemptive ones.",
		  "c": "Priority impacts execution order but not necessarily the core scheduling performance unless priority inversion occurs.",
		  "d": "Available memory affects process loading and swapping, not specifically preemptive scheduling performance."
		},
		"correctAnswer": "a",
		"difficulty": "beginner"
	  },
	  {
		"question": "In a non-preemptive scheduling system, how does the system handle a newly arrived process?",
		"answers": {
		  "a": "It immediately interrupts the current process to start the new one",
		  "b": "It waits until the current process finishes before starting the new one",
		  "c": "It assigns a priority to the new process and waits for the next time slice",
		  "d": "It executes the new process in parallel with the current one"
		},
		"explanations": {
		  "a": "Non-preemptive scheduling does not interrupt a running process, even if a higher-priority one arrives.",
		  "b": "In non-preemptive scheduling, a newly arrived process must wait until the currently executing process completes.",
		  "c": "Time slices are associated with preemptive scheduling, not non-preemptive systems.",
		  "d": "Parallel execution is unrelated to the concept of scheduling and involves multiple CPUs or cores."
		},
		"correctAnswer": "b",
		"difficulty": "beginner"
	  },
	  {
		"question": "Which factor is least affected by the choice of scheduling method?",
		"answers": {
		  "a": "Turnaround time",
		  "b": "Context switching time",
		  "c": "CPU utilization",
		  "d": "Response time"
		},
		"explanations": {
		  "a": "Turnaround time can vary greatly depending on the order in which processes are scheduled.",
		  "b": "Context switching time changes significantly depending on how frequently the scheduler switches processes.",
		  "c": "CPU utilization typically remains high as long as processes are available, regardless of the scheduling algorithm.",
		  "d": "Response time is closely tied to how soon a process gets CPU access, which is influenced by scheduling."
		},
		"correctAnswer": "c",
		"difficulty": "intermediate"
	  },
	  {
		"question": "What is the main cause of higher context switching overhead in preemptive scheduling?",
		"answers": {
		  "a": "Frequent process interruptions",
		  "b": "Low process priority",
		  "c": "Long time slice duration",
		  "d": "Excessive CPU utilization"
		},
		"explanations": {
		  "a": "In preemptive scheduling, processes are frequently interrupted, causing more time spent on context switching rather than process execution.",
		  "b": "Low priority affects scheduling order, not context switch frequency directly.",
		  "c": "Long time slices actually reduce the number of context switches, lowering overhead.",
		  "d": "CPU utilization being high or low doesn't inherently cause context switching overhead."
		},
		"correctAnswer": "a",
		"difficulty": "intermediate"
	  },
	  {
		"question": "How does the non-preemptive scheduling method affect system responsiveness?",
		"answers": {
		  "a": "It improves system responsiveness by quickly switching between tasks",
		  "b": "It degrades system responsiveness as a process must complete before another can start",
		  "c": "It does not affect system responsiveness",
		  "d": "It leads to faster execution of critical processes"
		},
		"explanations": {
		  "a": "Quick task switching is a feature of preemptive scheduling, not non-preemptive scheduling.",
		  "b": "In non-preemptive scheduling, processes must finish before another can be executed, which may lead to slower system responsiveness.",
		  "c": "Scheduling method directly impacts responsiveness, so it does have an effect.",
		  "d": "Critical processes may have to wait in non-preemptive scheduling, leading to slower response."
		},
		"correctAnswer": "b",
		"difficulty": "beginner"
	  },
	  {
		"question": "Which scheduling algorithm is more likely to maximize CPU utilization?",
		"answers": {
		  "a": "Preemptive scheduling",
		  "b": "Non-preemptive scheduling",
		  "c": "Round-robin",
		  "d": "First-come, first-served"
		},
		"explanations": {
		  "a": "Preemptive scheduling can ensure that the CPU is always doing productive work by assigning time slices dynamically.",
		  "b": "Non-preemptive scheduling might leave the CPU idle if a long-running job blocks others.",
		  "c": "Round-robin provides fairness but might increase context switches, reducing CPU time used for actual processing.",
		  "d": "FCFS may lead to the convoy effect where short jobs wait behind long jobs, lowering CPU efficiency."
		},
		"correctAnswer": "a",
		"difficulty": "advanced"
	  },
	  {
		"question": "In a preemptive scheduling system, what happens when a process runs out of its time slice?",
		"answers": {
		  "a": "The process is removed from the queue",
		  "b": "The process is paused and added back to the ready queue",
		  "c": "The process is completed and removed from the system",
		  "d": "The process is immediately restarted from the beginning"
		},
		"explanations": {
		  "a": "Processes are not removed from the queue unless they complete or are terminated.",
		  "b": "In preemptive scheduling, when a process runs out of its time slice, it is paused and placed back in the ready queue for future execution.",
		  "c": "Processes are only removed after completing, not simply after their time slice ends.",
		  "d": "Processes resume from where they left off; they are not restarted from the beginning."
		},
		"correctAnswer": "b",
		"difficulty": "beginner"
	  }
	]
  }
  